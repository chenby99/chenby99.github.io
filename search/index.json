[{"content":" 【写在前面】\n这是2023-2024春季学期操作系统课程有关xv6 lab部分的实验报告，参考了很多网络资源，解释也不一定正确，仅作为留档，参考需谨慎。\nLab 地址：6.1810 / Fall 2024\n参考：\nyali-hzy/xv6-labs-2024: MIT 6.1810 assignments\n[mit6.s081] 笔记 Lab10: Mmap | 文件内存映射 | Miigon\u0026rsquo;s blog\n实验任务 本实验需要实现 UNIX 的 mmap 和 munmap 系统调用。此系统调用会把文件映射到用户空间的内存，这样用户可以直接通过内存来修改和访问文件。\n实验手册中给出了mmap() 的定义声明：\n1 void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset); 映射描述符为 fd 的文件的前 length 个字节到 addr 开始的位置。并且加上 offset 的偏移量。如果 addr 参数为 0，系统会自动分配一个空闲的内存区域来映射，成功返回这个地址，如果失败则返回 0xffffffffffffffff。实验需要支持 addr 和 offset 都为 0 的情况，不用考虑用户指定内存和文件偏移量。\nprot 和 flags 是标志位。prot 有可读/可写/可执行选项，规定了能对映射后文件做的操作。实验假设 prot 是 PROT_READ 或 PROT_WRITE 或两者。\nflags 则决定如果在内存映射文件中做了修改，是否要在取消映射时，把这些修改更新到文件中。实验只需要实现 MAP_SHARED（映射内存的修改应写回文件） 和 MAP_PRIVATE （不应写回）两个选项。\n手册中unmap() 的定义声明：\n1 int munmap(void *addr, size_t length); 意思是取消从 addr 开始的，长度为 length 的文件映射。\n实验思路 添加 mmap 和 munmap 系统调用，以便 user/mmaptest.c 可以编译。 根据提示“Define a structure corresponding to the VMA (virtual memory area) described in the \u0026ldquo;virtual memory for applications\u0026rdquo; lecture. This should record the address, length, permissions, file, etc\u0026hellip;”，定义VMA结构体，包含 mmap 映射的内存区域的各种必要信息，比如开始地址、大小、所映射文件、文件内偏移以及权限等。在 proc 结构体末尾为每个进程加上 16 个 vma 空槽，并添加一个变量用于存储映射 mmap 页的顶部地址。 在 kernel/sysfile.c中添加mmap的系统调用实现：在16个vma槽中找到空槽，并将一个vam添加到进程的映射区域表中。在最后根据提示使用 filedup()将文件的引用计数增加一。 在usertrap()中修改代码处理在内存映射区域中触发缺页错误时，分配一页可用的物理内存，将相关文件的 4096 字节读入该页，并将其映射到用户地址空间。根据提示，可以使用 readi 读取文件，并且正确设置页面的权限。 为了代码编写方便，将获取可用于mmap映射的虚拟地址空间和更新进程的内存映射顶部指针两个功能封装为了get_free_mmap_vm和update_mmap_top两个辅助函数。 在 kernel/sysfile.c中添加munmap的系统调用实现：将一个 vma 所分配的所有页释放，如果未映射的页面已被修改且 flag 映射为 MAP_SHARED ，将已经修改的页写回磁盘。根据提示，mmaptest 不会检查非脏页是否未被写回，因此可以不看 D 位（判断是否被修改的脏位）就写回页面，代码逻辑与filewrite类似。 在 proc.c 中添加处理进程 vma 的各部分代码。 让 allocproc 初始化进程的时候，将 vma 槽都清空 exit 退出程序时，清理所有vma映射，并在需要的时候写回磁盘（与munmap的系统调用中写入的逻辑类似，代码基本一致） fork ：拷贝父进程在使用的 vma，但是不拷贝物理页，确保子进程与父进程具有相同的映射区域。 代码具体实现参照代码注释 实现代码 添加mmap 和 munmap 系统调用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // kernel/syscall.c extern uint64 sys_mmap(void); extern uint64 sys_munmap(void); [SYS_mmap] sys_mmap, [SYS_munmap] sys_munmap, // kernel/syscall.h #define SYS_mmap 22 #define SYS_munmap 23 // user/user.h #ifdef LAB_MMAP void *mmap(void *addr, size_t len, int prot, int flags,int fd, off_t offset); int munmap(void *addr, size_t len); #endif // user/usys.pl entry(\u0026#34;mmap\u0026#34;); entry(\u0026#34;munmap\u0026#34;); 定义vma结构体\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // kernel/proc.h struct vma { uint64 addr; // 起始地址 unsigned long len; // 长度 int prot; // 权限标志位 int flags; // map_shared or map_private long int offset; // 偏移量 struct file *file; // 映射的文件 int inuse; // vma 结构体是否代表了一个正在使用的文件映射 }; #define NVMA 16 // Per-process state struct proc { struct spinlock lock; // ... struct VMA vma[NVMA]; // 加上16个vma空槽 uint64 mmap_top; // 存储映射mmap页的顶部地址 }; sys_mmap()实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // kernel/sysfile.c uint64 sys_mmap(void) { // 声明系统调用参数变量 uint64 addr,offset; unsigned long len; int prot, flags, fd; struct proc *p = myproc(); // 获取进程 struct file* file; // 获取参数 argaddr(0, \u0026amp;addr); argaddr(1, \u0026amp;len); argint(2, \u0026amp;prot); argint(3, \u0026amp;flags); argfd(4, \u0026amp;fd, \u0026amp;file); // 同时取得文件和描述符 argaddr(5, \u0026amp;offset); // 检查保护标志与文件权限是否兼容： if(((prot \u0026amp; PROT_READ) \u0026amp;\u0026amp; !file-\u0026gt;readable) || ((prot \u0026amp; PROT_WRITE) \u0026amp;\u0026amp; (flags \u0026amp; MAP_SHARED) \u0026amp;\u0026amp; !file-\u0026gt;writable)) return -1; // 权限不匹配，返回错误 // 如果调用者指定地址为0，由内核自动选择映射地址 if(addr == 0) addr = get_free_mmap_vm(len); // 获取空闲的映射地址区域 // 遍历进程的VMA数组，找到空的 for(int i = 0; i \u0026lt; NVMA; i++){ // 跳过已使用且地址大于新地址的VMA if(p-\u0026gt;vma[i].in_use == 1 \u0026amp;\u0026amp; p-\u0026gt;vma[i].addr \u0026gt; addr) continue; // 将i位置之后的VMA向后移动，为新VMA腾出空间 for(int j = NVMA-1; j \u0026gt; i; j--) p-\u0026gt;vma[j] = p-\u0026gt;vma[j-1]; // 移动VMA条目 // 初始化新的VMA条目 p-\u0026gt;vma[i].addr = addr; p-\u0026gt;vma[i].len = len; p-\u0026gt;vma[i].prot = prot; p-\u0026gt;vma[i].flags = flags; p-\u0026gt;vma[i].file = file; p-\u0026gt;vma[i].offset = offset; p-\u0026gt;vma[i].in_use = 1; break; } update_mmap_top(); // 更新进程的地址空间顶部指针 filedup(file); // 增加引用计数 return addr; // 返回映射的起始地址 } sys_munmap()实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 // kernel/sysfile.c uint64 sys_munmap(void) { uint64 addr; unsigned long len; struct proc *p = myproc(); // 获取进程 // 获取系统调用参数：起始地址和长度 argaddr(0, \u0026amp;addr); argaddr(1, \u0026amp;len); for(int i = 0; i \u0026lt; NVMA; i++){ // 遍历进程的VMA数组 // 检查当前VMA是否包含要取消映射的区域 if(p-\u0026gt;vma[i].in_use == 1 \u0026amp;\u0026amp; p-\u0026gt;vma[i].addr \u0026lt;= addr \u0026amp;\u0026amp; addr + len \u0026lt;= p-\u0026gt;vma[i].addr + p-\u0026gt;vma[i].len){ // 遍历要取消映射的每一页 for(uint64 j = addr; j \u0026lt; addr + len; j += PGSIZE){ uint64 pa = walkaddr(p-\u0026gt;pagetable, j); // 获取物理地址 if(pa != 0){ // 如果是共享映射且可写，需要写回文件 if(p-\u0026gt;vma[i].flags \u0026amp; MAP_SHARED \u0026amp;\u0026amp; p-\u0026gt;vma[i].prot \u0026amp; PROT_WRITE){ struct inode *ip = p-\u0026gt;vma[i].file-\u0026gt;ip; begin_op(); ilock(ip); int n = PGSIZE; // 要写入的字节数（不超过文件大小） if(p-\u0026gt;vma[i].offset + j - p-\u0026gt;vma[i].addr + n \u0026gt; p-\u0026gt;vma[i].file-\u0026gt;ip-\u0026gt;size) n = p-\u0026gt;vma[i].file-\u0026gt;ip-\u0026gt;size - (p-\u0026gt;vma[i].offset + j - p-\u0026gt;vma[i].addr); // 执行文件写入 writei(ip, 0, pa, p-\u0026gt;vma[i].offset + j - p-\u0026gt;vma[i].addr, n); iunlock(ip); end_op(); } // 取消页表映射并释放物理页 uvmunmap(p-\u0026gt;pagetable, j, 1, 1); } } // 调整VMA元数据 if(p-\u0026gt;vma[i].addr == addr \u0026amp;\u0026amp; p-\u0026gt;vma[i].len == len){ // 情况1：完全取消映射整个VMA fileclose(p-\u0026gt;vma[i].file); p-\u0026gt;vma[i].in_use = 0; for(int j = i; j \u0026lt; NVMA-1; j++) p-\u0026gt;vma[j] = p-\u0026gt;vma[j+1]; } else if(p-\u0026gt;vma[i].addr == addr){ // 情况2：从开头取消映射部分区域 p-\u0026gt;vma[i].addr += len; p-\u0026gt;vma[i].len -= len; p-\u0026gt;vma[i].offset += len; } else if(p-\u0026gt;vma[i].addr + p-\u0026gt;vma[i].len == addr + len){ // 情况3：从末尾取消映射部分区域 p-\u0026gt;vma[i].len -= len; } else { // 情况4：中间区域（不支持） panic(\u0026#34;munmap: hole in vma not supported\u0026#34;); } break; } } update_mmap_top(); // 更新进程的内存映射信息 return 0; } get_free_mmap_vm()和update_mmap_top()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // kernel/sysfile.c uint64 get_free_mmap_vm(unsigned long len) { struct proc *p = myproc(); // 获取当前进程 for(int i = 1; i \u0026lt; NVMA; i++){ if(p-\u0026gt;vma[i].in_use == 1){ // 检查当前和前一个VMA是否都有效 if(p-\u0026gt;vma[i-1].addr - PGROUNDUP(p-\u0026gt;vma[i].addr + p-\u0026gt;vma[i].len) \u0026gt;= len) return PGROUNDUP(p-\u0026gt;vma[i].addr + p-\u0026gt;vma[i].len); // 返回当前VMA结束地址对齐后的位置 } else break; // 遇到未使用的VMA槽位，停止搜索 } return PGROUNDDOWN(p-\u0026gt;mmap_top - len); // 如果未找到合适空隙，则从mmap_top向下分配 } void update_mmap_top(void) // 获取当前进程 { struct proc *p = myproc(); for(int i = 0; i \u0026lt; NVMA; i++){ if(p-\u0026gt;vma[i].in_use == 1) // 如果VMA正在使用中 p-\u0026gt;mmap_top = p-\u0026gt;vma[i].addr; // 更新mmap_top为当前VMA的起始地址 } } trap.c中修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 // 添加头文件 #include \u0026#34;fcntl.h\u0026#34; #include \u0026#34;sleeplock.h\u0026#34; #include \u0026#34;fs.h\u0026#34; #include \u0026#34;file.h\u0026#34; // ... void usertrap(void) { // ... } else { // 如果不是系统调用或设备中断，处理其他异常 if(r_scause() == 13 || r_scause() == 15){ // 检查是否是缺页异常（13=读取缺页，15=写入缺页） for(int i = 0; i \u0026lt; NVMA; i++){ //遍历寻找 uint64 va = r_stval(); // 获取触发异常的虚拟地址 struct vma v = p-\u0026gt;vma[i]; // 检查：1. VMA有效 2. 异常地址在该VMA范围内 if(v.in_use \u0026amp;\u0026amp; v.addr \u0026lt;= va \u0026amp;\u0026amp; va \u0026lt; v.addr + v.len){ void *pa = kalloc(); // 分配物理页 memset(pa, 0, PGSIZE); // 清空新分配的物理页 if(pa == 0){ printf(\u0026#34;usertrap(): kalloc\\n\u0026#34;); goto bad; // 如果出错 跳转到错误处理 } // 从磁盘读取数据 struct inode *ip = v.file-\u0026gt;ip; // 获取VMA关联的文件inode、 begin_op(); ilock(ip); readi(ip, 0, (uint64)pa, v.offset + PGROUNDDOWN(va - v.addr), PGSIZE); iunlock(ip); end_op(); // 根据VMA保护标志添加权限： int perm = PTE_U; if(v.prot \u0026amp; PROT_READ) perm |= PTE_R; if(v.prot \u0026amp; PROT_WRITE) perm |= PTE_W; if(v.prot \u0026amp; PROT_EXEC) perm |= PTE_X; // 权限验证 if((r_scause() == 13 \u0026amp;\u0026amp; !(perm \u0026amp; PTE_R)) || (r_scause() == 15 \u0026amp;\u0026amp; !(perm \u0026amp; PTE_W))){ kfree(pa); goto bad; // 如果出错 跳转到错误处理 } // 建立页表映射 if(mappages(p-\u0026gt;pagetable, PGROUNDDOWN(va), PGSIZE, (uint64)pa, perm) != 0){ kfree(pa); printf(\u0026#34;usertrap(): mappages\\n\u0026#34;); goto bad; // 如果出错 跳转到错误处理 } goto good; // 成功处理缺页，跳转到恢复点 } } } bad: printf(\u0026#34;usertrap(): unexpected scause 0x%lx pid=%d\\n\u0026#34;, r_scause(), p-\u0026gt;pid); printf(\u0026#34; sepc=0x%lx stval=0x%lx\\n\u0026#34;, r_sepc(), r_stval()); setkilled(p); } good: if(killed(p)) exit(-1); // ... } proc.c中修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 // 添加头文件 #include \u0026#34;fcntl.h\u0026#34; #include \u0026#34;sleeplock.h\u0026#34; #include \u0026#34;fs.h\u0026#34; #include \u0026#34;file.h\u0026#34; // ... static struct proc* allocproc(void) { struct proc *p; // ... p-\u0026gt;mmap_top = TRAPFRAME - 2*PGSIZE; // 初始化mmap区域顶部地址 memset(p-\u0026gt;vma, 0, sizeof(p-\u0026gt;vma)); // 清空VMA数组 return p; } // ... int fork(void) { int i, pid; struct proc *np; // ... // 复制VMA结构 for(i = 0; i \u0026lt; NVMA; i++) if(p-\u0026gt;vma[i].in_use){ // 只复制在使用VMA np-\u0026gt;vma[i] = p-\u0026gt;vma[i]; filedup(np-\u0026gt;vma[i].file); } np-\u0026gt;mmap_top = p-\u0026gt;mmap_top; // 复制顶部地址 // ... } // ... void exit(int status) { struct proc *p = myproc(); if(p == initproc) panic(\u0026#34;init exiting\u0026#34;); // 清理所有VMA映射 for(int i = 0; i \u0026lt; NVMA; i++) if(p-\u0026gt;vma[i].in_use == 1){ for(uint64 a = p-\u0026gt;vma[i].addr; a \u0026lt; p-\u0026gt;vma[i].addr + p-\u0026gt;vma[i].len; a += PGSIZE){ uint64 pa = walkaddr(p-\u0026gt;pagetable, a); // 获取物理地址 if(pa != 0){ if(p-\u0026gt;vma[i].prot \u0026amp; PROT_WRITE \u0026amp;\u0026amp; p-\u0026gt;vma[i].flags \u0026amp; MAP_SHARED){ struct inode *ip = p-\u0026gt;vma[i].file-\u0026gt;ip; begin_op(); ilock(ip); int n = PGSIZE; // 写入长度 if(p-\u0026gt;vma[i].offset + PGROUNDDOWN(a - p-\u0026gt;vma[i].addr) + PGSIZE \u0026gt; p-\u0026gt;vma[i].file-\u0026gt;ip-\u0026gt;size) n = p-\u0026gt;vma[i].file-\u0026gt;ip-\u0026gt;size - (p-\u0026gt;vma[i].offset + PGROUNDDOWN(a - p-\u0026gt;vma[i].addr)); writei(ip, 0, pa, p-\u0026gt;vma[i].offset + PGROUNDDOWN(a - p-\u0026gt;vma[i].addr), n); // 写入文件 iunlock(ip); end_op(); } uvmunmap(p-\u0026gt;pagetable, a, 1, 1); // 取消映射并释放物理页 } } fileclose(p-\u0026gt;vma[i].file); p-\u0026gt;vma[i].in_use = 0; } // ... } 实验结果 \u0026hellip; \u0026hellip;\n","date":"2025-07-11T21:03:27+08:00","permalink":"https://chenby99.github.io/p/mit6.1810lab9-mmap/","title":"[mit6.1810]Lab9: mmap"},{"content":" 【写在前面】\n这是2023-2024春季学期操作系统课程有关xv6 lab部分的实验报告，参考了很多网络资源，解释也不一定正确，仅作为留档，参考需谨慎。\nLab 地址：6.1810 / Fall 2024\n参考：\nyali-hzy/xv6-labs-2024: MIT 6.1810 assignments\n[mit6.s081] 笔记 Lab8: Locks | 锁优化 | Miigon\u0026rsquo;s blog\n[MIT 6.s081] Xv6 Lab9 Lockss 实验记录 | tzyt的博客\nMemory allocator 在开始实验前，kalloctest 的输出：\n实验任务分析 实验任务是优化 xv6 操作系统的内存分配器，以减少锁争用。具体来说，程序 user/kalloctest 会对 xv6 的内存分配器施加压力，通过三个进程不断扩展和收缩它们的地址空间，从而产生大量的 kalloc 和 kfree 调用，而 kalloc 和 kfree 需要获取 kmem.lock 锁。实验要求我们重新设计内存分配器，避免使用单一的锁和空闲列表，采用每个 CPU 对应一个空闲列表并配备独立锁的方式，并在需要时实现不同 CPU 之间的内存窃取，以减少锁争用。\n具体要求：\nYour job is to implement per-CPU freelists, and stealing when a CPU\u0026rsquo;s free list is empty. You must give all of your locks names that start with \u0026ldquo;kmem\u0026rdquo;. That is, you should call initlock for each of your locks, and pass a name that starts with \u0026ldquo;kmem\u0026rdquo;. Run kalloctest to see if your implementation has reduced lock contention. To check that it can still allocate all of memory, run usertests sbrkmuch. Your output will look similar to that shown below, with much-reduced contention in total on kmem locks, although the specific numbers will differ. Make sure all tests in usertests -q pass. make grade should say that the kalloctests pass.\n相关源码分析 kmem kmem 是一个全局的内存管理结构，用于管理内核内存的分配和释放。它包含一个锁和一个空闲链表，用于保护和管理内存分配的同步操作。在修改前的 xv6 实现中，kmem 是一个单一的结构体实例，所有 CPU 都共享同一个 kmem 结构体，这会导致多 CPU 环境下锁争用严重。\nkinit 函数 初始化锁：initlock 函数初始化一个自旋锁，用于保护内存分配器的空闲链表，防止多个 CPU 或线程同时访问导致数据不一致。 初始化内存范围：freerange 函数将从 end 到 PHYSTOP 的物理内存标记为可用内存，end 是内核代码和数据的结束地址，PHYSTOP 是物理内存的上限。 kfree 函数 参数检查：检查传入的物理地址是否对齐、是否在有效范围内，如果无效则调用 panic 函数终止系统。 填充内存：使用 memset 函数将释放的内存页面填充为特定值（1），用于检测是否有悬垂指针（dangling pointer）引用已释放的内存。 更新空闲链表：获取锁后，将释放的内存块添加到空闲链表的头部，然后释放锁。 kalloc 函数 获取空闲内存块：获取锁后，从空闲链表中取出第一个内存块，并更新空闲链表的头部。 填充内存：如果成功分配到内存块，将其填充为特定值（这里是 5），用于检测是否有悬垂指针引用已释放的内存。 返回内存块指针：返回分配的内存块的指针，如果没有可用内存块则返回空指针。 NCPU 根据提示：“You can use the constant NCPU from kernel/param.h”，查阅param.h可知 NCPU 常量表示最大 CPU 数量，可以用于设置kmem大小。\n1 #define NCPU 8 // maximum number of CPUs 实验任务实现思路 把用于管理内核内存的分配和释放的结构体kmem修改为一个大小为NCPU的数组，确保在最大CPU数量时，每个CPU都能有独立的空闲列表和对应的锁。 根据修改后的kmem对照源码的功能修改相关的函数。与源码主要的区别在于： 初始化锁时需要命名不同的名字。根据提示：“Have a look at the snprintf function in kernel/sprintf.c for string formatting ideas. ”，可以使用snprintf 函数 因为有多个CPU多个锁，操作前需要获取当前CPU的标识符并且获取当前CPU对应的锁 根据提示：“The function cpuid returns the current core number, but it\u0026rsquo;s only safe to call it and use its result when interrupts are turned off. You should use push_off() and pop_off() to turn interrupts off and on. ”，在获取 CPU ID 的过程中，需要禁用中断以确保操作的原子性，避免在多 CPU 环境下出现竞态条件） 增加内存窃取机制：当kalloc 函数中无法获取到获取空闲内存块时，遍历其他CPU的空闲链表窃取空闲的内存块。为了代码编写方便且尽量减少对其他 CPU 空闲链表的结构改变，窃取时选择其他CPU空闲链表从头到遍历的第一个中断处的空闲内存块，即找到的第一段连续内存块。 修改代码（kalloc.c) 修改结构体kmem为大小为NCPU的数组\n1 2 3 4 struct { struct spinlock lock; struct run *freelist; } kmem[NCPU]; 修改kinit()\n1 2 3 4 5 6 7 8 9 10 11 void kinit() { //initlock(\u0026amp;kmem.lock, \u0026#34;kmem\u0026#34;); char lock_name[10]; // 存储名字的数组 for(int i=0;i\u0026lt;NCPU;i++){ snprintf(lock_name,10,\u0026#34;kmem_%d\u0026#34;,i); // 命名为\u0026#39;kmem_i\u0026#39; initlock(\u0026amp;kmem[i].lock,lock_name); // 为每个CPU初始化自旋锁 } freerange(end, (void*)PHYSTOP); } 修改kfree()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void kfree(void *pa) { struct run *r; if(((uint64)pa % PGSIZE) != 0 || (char*)pa \u0026lt; end || (uint64)pa \u0026gt;= PHYSTOP) panic(\u0026#34;kfree\u0026#34;); // Fill with junk to catch dangling refs. memset(pa, 1, PGSIZE); r = (struct run*)pa; // acquire(\u0026amp;kmem.lock); // r-\u0026gt;next = kmem.freelist; // kmem.freelist = r; // release(\u0026amp;kmem.lock); push_off(); // 临时禁用中断，避免获取CPU的标识符时被打断 int cpu = cpuid(); // 获取当前CPU的标识符 pop_off(); // 恢复中断 acquire(\u0026amp;kmem[cpu].lock); // 获取当前CPU对应的锁 r-\u0026gt;next = kmem[cpu].freelist; kmem[cpu].freelist = r; // 将释放的内存块添加到当前 CPU 的空闲链表中 release(\u0026amp;kmem[cpu].lock); // 释放锁 } 修改kalloc()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 void * kalloc(void) { struct run *r; // acquire(\u0026amp;kmem.lock); // r = kmem.freelist; push_off(); int cpu = cpuid(); // 获取当前CPU的标识符 pop_off(); acquire(\u0026amp;kmem[cpu].lock); // 获取当前CPU对应的锁 r = kmem[cpu].freelist;// 从当前CPU的空闲链表获取第一个内存块 // if(r) // kmem.freelist = r-\u0026gt;next; // release(\u0026amp;kmem.lock); if(r){ // 如果有空闲内存块 kmem[cpu].freelist = r-\u0026gt;next; // 更新当前CPU的空闲链表，跳过当前分配的内存块 } else{ // 如果没有空闲内存块，从其他CPU窃取内存 for(int i = 0;i \u0026lt; NCPU;i++){ //遍历所有cpu if(i == cpu){ continue; // 跳过当前cpu } acquire(\u0026amp;kmem[i].lock); // 获取锁 if(kmem[i].freelist == 0){ // 如果空闲链表为空 release(\u0026amp;kmem[i].lock); //释放锁 continue; // 去下一个cpu继续找 } // 空闲链表不为空 struct run *tmp = kmem[i].freelist; // 获取空闲链表头指针 for(int j = 0; j \u0026lt; 512; j++){ // 遍历链表，tmp指向最后一个next不为空的位置 if(tmp-\u0026gt;next) tmp = tmp-\u0026gt;next; else break; } kmem[cpu].freelist = kmem[i].freelist; // 将找到的这个空闲链表头转移到当前 CPU kmem[i].freelist = tmp-\u0026gt;next; // 更新被窃取的cpu的空闲链表 tmp-\u0026gt;next = 0; // 断开窃取的内存块与原链表的连接 r = kmem[cpu].freelist; // 获取空闲内存块 kmem[cpu].freelist = r-\u0026gt;next; // 更新链表 release(\u0026amp;kmem[i].lock); // 释放窃取的cpu的锁 break; } } release(\u0026amp;kmem[cpu].lock); // 释放当前cpu锁 if(r) memset((char*)r, 5, PGSIZE); // fill with junk return (void*)r; } 测试结果 \u0026hellip; \u0026hellip;\nBuffer cache 实验任务 原始代码使用单个全局锁（bcache.lock）保护所有缓存块，当多进程同时访问文件系统时出现严重锁竞争。bcache.lock 锁用于保护磁盘区块缓存，在原本的设计中，由于该锁的存在，多个进程不能同时操作（申请、释放）磁盘缓存。\nbcachetest 模拟创建多个进程，反复读取不同的文件，以在 bcache.lock 上产生争抢。实验需要我们修改块缓存，使得在运行 bcachetest 时，bcache 中所有锁的 acquire 循环迭代次数接近于零。\n源码分析 通过阅读实验要求，发现有关buffer cache的代码主要在kernel/bio.c 中。其中主要接口包括：\nbread：获取并读取磁盘块到缓冲区 bwrite：将缓冲区的内容写回磁盘 brelse：释放缓冲区并更新其在LRU链表中的位置 bpin 和 bunpin：分别增加和减少缓冲区的引用计数 内部实现包括：\nbinit ：初始化函数，用于设置缓冲区缓存的基本结构，包括初始化自旋锁、双向链表和缓冲区的睡眠锁 bget ：在缓冲区缓存中查找或分配一个缓冲区 数据结构：\n1 2 3 4 5 6 7 8 9 10 // kernel/bio.c struct { struct spinlock lock; struct buf buf[NBUF]; // Linked list of all buffers, through prev/next. // Sorted by how recently the buffer was used. // head.next is most recent, head.prev is least. struct buf head; } bcache; 原版 xv6 的设计中，使用双向链表存储所有的区块缓存\n在读写硬盘的时候，需要通过 bread() 函数得到相应的缓存：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // Return a locked buf with the contents of the indicated block. struct buf* bread(uint dev, uint blockno) { struct buf *b; b = bget(dev, blockno); if(!b-\u0026gt;valid) { virtio_disk_rw(b, 0); b-\u0026gt;valid = 1; } return b; } 首先调用了bget()用于判断是否之前已经缓存过了硬盘中的这个块：如果有，那就直接返回对应的缓存；如果未缓存，则分配一个最近最少使用的未使用缓存。阅读源码：\n可以看到，所有的缓存被串到了一个双向链表里。链表的第一个元素是最近使用的，最后一个元素是很久没有使用的。\n每次 bget() 的时候会先遍历一遍链表，检查当前块是否已经被存到缓存里了。如果没有，那就会从后到前遍历链表（意味着是从最久没有使用的开始找），找到第一个引用计数为 0 （代表没有程序正在使用这个块）的缓存作为当前块的缓存。\n这就造成了，在任何时候想要分配缓存，都需要竞争这个链表的锁。\n可能你会想到使使用前一个实验的方法来优化，但把缓存分配到不同核心的方法是行不通的。因为分配页帧和回收页帧的时候，只需要有一个核心参与，而且分配后某个页帧只会被一个进程访问。\n而分配出去的块缓存可能会被不同进程访问。比如不同的进程可以访问和写入同一个块缓存。如果预先按照核心分配缓存，有很大概率进程需要的缓存不属于当前核心。那就需要去一个一个的遍历别核心的块缓存，造成性能下降。（不过如果每个块缓存单独持有一个锁，粒度更小了会不会性能更好点）。\n实验描述中给我们的提示是实现一个散列表。散列表会把块号映射到块缓存的桶，那么只有两个进程试图操作同一个桶中的块缓存，才会造成竞争。而且在查找所需块缓存时页不需要遍历所有的缓存，只需要遍历对应的桶。\n当然，在对应桶中没有足够缓存时，我们可以像在 kalloc() 中一样，从别的桶中偷缓存。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // Look through buffer cache for block on device dev. // If not found, allocate a buffer. // In either case, return locked buffer. static struct buf* bget(uint dev, uint blockno) { struct buf *b; acquire(\u0026amp;bcache.lock); // Is the block already cached? for(b = bcache.head.next; b != \u0026amp;bcache.head; b = b-\u0026gt;next){ if(b-\u0026gt;dev == dev \u0026amp;\u0026amp; b-\u0026gt;blockno == blockno){ b-\u0026gt;refcnt++; release(\u0026amp;bcache.lock); acquiresleep(\u0026amp;b-\u0026gt;lock); return b; } } // Not cached. // Recycle the least recently used (LRU) unused buffer. for(b = bcache.head.prev; b != \u0026amp;bcache.head; b = b-\u0026gt;prev){ if(b-\u0026gt;refcnt == 0) { b-\u0026gt;dev = dev; b-\u0026gt;blockno = blockno; b-\u0026gt;valid = 0; b-\u0026gt;refcnt = 1; release(\u0026amp;bcache.lock); acquiresleep(\u0026amp;b-\u0026gt;lock); return b; } } panic(\u0026#34;bget: no buffers\u0026#34;); } 实验思路 与kalloc中一个物理页分配后就只归单个进程所管不同，bcache 中的缓存块实现的是真正的共享。所以不能使用kmem 中为每个 CPU 预先分割一部分专属的页的方法。 通过实验要求提示：”We suggest you look up block numbers in the cache with a hash table that has a lock per hash bucket. “主要解决锁竞争的思路是：使用哈希桶降低锁的粒度，用更精细的锁来降低出现竞争的概率。 首先根据提示：“It is OK to use a fixed number of buckets and not resize the hash table dynamically. Use a prime number of buckets (e.g., 13) to reduce the likelihood of hashing conflicts. ”，设定固定质数（13）个数的哈希桶，将全局链表替换为哈希桶结构，把块缓存号映射到块缓存的桶，每个桶有独立的锁。这样只有两个进程试图操作同一个桶中的块缓存，才会造成竞争。 初始化：需要初始化每一个桶的双向链表及其对应的锁。与上一个实验类似，使用 snprintf 为每个桶锁生成名称。开始先将所有缓冲区初始化到bucket[0]中 依次根据数据结构的改变修改其他函数的具体实现： bget ： 根据blockno计算哈希值，在对应的桶中查找缓冲区。与原本的逻辑大致相同，查找时需要启用锁保护。 需要检查两次目标桶，一次五全局锁，一次有全局锁（若其他线程在第一次释放锁后缓存了该块，此次能检测到），确保只有一个线程能执行缓存分配，防止重复缓存。 修改分配机制：如果在目标哈希桶中找不到，则遍历所有哈希桶，寻找未使用的缓冲区。找到未使用的缓冲区后，将其从原桶中移除，并重新插入到目标桶中。根据提示“In bget you can select any block that has refcnt == 0 instead of the least-recently used one. ”，放弃LRU，任意选择refcnt==0的缓冲区。 brelse：与原本逻辑大致相同，加入计算哈希值，操作对应桶即可。 bpin 和 bunpin：与原本逻辑大致相同，加入计算哈希值，操作对应桶即可。 根据提示 “Your solution might need to hold two locks in some cases; for example, during eviction you may need to hold the bcache lock and a lock per bucket. Make sure you avoid deadlock. ”和“When replacing a block, you might move a struct buf from one bucket to another bucket, because the new block hashes to a different bucket. You might have a tricky case: the new block might hash to the same bucket as the old block. Make sure you avoid deadlock in that case. ” 需要按桶索引顺序加锁、操作完成后逆序释放锁，并且避免在持有锁的情况下再次尝试获取其他锁，避免死锁问题。 实现代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 // Buffer cache. // // The buffer cache is a linked list of buf structures holding // cached copies of disk block contents. Caching disk blocks // in memory reduces the number of disk reads and also provides // a synchronization point for disk blocks used by multiple processes. // // Interface: // * To get a buffer for a particular disk block, call bread. // * After changing buffer data, call bwrite to write it to disk. // * When done with the buffer, call brelse. // * Do not use the buffer after calling brelse. // * Only one process at a time can use a buffer, // so do not keep them longer than necessary. #include \u0026#34;types.h\u0026#34; #include \u0026#34;param.h\u0026#34; #include \u0026#34;spinlock.h\u0026#34; #include \u0026#34;sleeplock.h\u0026#34; #include \u0026#34;riscv.h\u0026#34; #include \u0026#34;defs.h\u0026#34; #include \u0026#34;fs.h\u0026#34; #include \u0026#34;buf.h\u0026#34; #define NBUCKET 13 // 定义哈希桶数量（使用质数减少冲突） struct { struct spinlock lock; // 全局锁 struct buf buf[NBUF]; struct buf bucket[NBUCKET]; // 哈希桶头节点数组 struct spinlock bucket_lock[NBUCKET]; // 每个桶的独立锁 // Linked list of all buffers, through prev/next. // Sorted by how recently the buffer was used. // head.next is most recent, head.prev is least. } bcache; void binit(void) { struct buf *b; char name[32]; initlock(\u0026amp;bcache.lock, \u0026#34;bcache\u0026#34;); // Create linked list of buffers for(int i = 0; i \u0026lt; NBUCKET; i++) { snprintf(name, sizeof(name), \u0026#34;bcache_bucket_lock_%d\u0026#34;, i); // 锁命名 initlock(\u0026amp;bcache.bucket_lock[i], name); // 初始化每个桶的锁 bcache.bucket[i].prev = \u0026amp;bcache.bucket[i]; bcache.bucket[i].next = \u0026amp;bcache.bucket[i]; // 初始化空链表 } // 所有缓冲区初始分配到桶0 for(b = bcache.buf; b \u0026lt; bcache.buf+NBUF; b++){ b-\u0026gt;next = bcache.bucket[0].next; b-\u0026gt;prev = \u0026amp;bcache.bucket[0]; initsleeplock(\u0026amp;b-\u0026gt;lock, \u0026#34;buffer\u0026#34;); bcache.bucket[0].next-\u0026gt;prev = b; bcache.bucket[0].next = b; } } // Look through buffer cache for block on device dev. // If not found, allocate a buffer. // In either case, return locked buffer. static struct buf* bget(uint dev, uint blockno) { struct buf *b; int hashcode = blockno % NBUCKET; // 计算哈希值 acquire(\u0026amp;bcache.bucket_lock[hashcode]); // 只获取目标桶锁 // Is the block already cached? for(b = bcache.bucket[hashcode].next; b != \u0026amp;bcache.bucket[hashcode]; b = b-\u0026gt;next){ if(b-\u0026gt;dev == dev \u0026amp;\u0026amp; b-\u0026gt;blockno == blockno){ b-\u0026gt;refcnt++; release(\u0026amp;bcache.bucket_lock[hashcode]); // 释放桶锁 acquiresleep(\u0026amp;b-\u0026gt;lock); // 获取睡眠锁 return b; } } release(\u0026amp;bcache.bucket_lock[hashcode]); //释放桶锁 // Not cached. // Recycle the least recently used (LRU) unused buffer. acquire(\u0026amp;bcache.lock); // 获取全局锁 acquire(\u0026amp;bcache.bucket_lock[hashcode]); // 再次获取目标桶锁 // 重新检查目标桶（在持有全局锁的情况下） for(b = bcache.bucket[hashcode].next; b != \u0026amp;bcache.bucket[hashcode]; b = b-\u0026gt;next){ if(b-\u0026gt;dev == dev \u0026amp;\u0026amp; b-\u0026gt;blockno == blockno){ b-\u0026gt;refcnt++; release(\u0026amp;bcache.bucket_lock[hashcode]); release(\u0026amp;bcache.lock); acquiresleep(\u0026amp;b-\u0026gt;lock); return b; } } for(int hashcode2 = 0; hashcode2 \u0026lt; NBUCKET; hashcode2++) { if(hashcode2 != hashcode) acquire(\u0026amp;bcache.bucket_lock[hashcode2]); // 获取其他桶锁 for(b = bcache.bucket[hashcode2].next; b != \u0026amp;bcache.bucket[hashcode2]; b = b-\u0026gt;next){ // 遍历当前桶 if(b-\u0026gt;refcnt == 0){ // 如果找到空的 // 从当前桶移除 b-\u0026gt;next-\u0026gt;prev = b-\u0026gt;prev; b-\u0026gt;prev-\u0026gt;next = b-\u0026gt;next; // 插入目标桶头部 b-\u0026gt;next = bcache.bucket[hashcode].next; b-\u0026gt;prev = \u0026amp;bcache.bucket[hashcode]; bcache.bucket[hashcode].next-\u0026gt;prev = b; bcache.bucket[hashcode].next = b; // 设置缓冲区元数据 b-\u0026gt;dev = dev; b-\u0026gt;blockno = blockno; b-\u0026gt;valid = 0; b-\u0026gt;refcnt = 1; // 释放锁 if(hashcode2 != hashcode) release(\u0026amp;bcache.bucket_lock[hashcode2]); release(\u0026amp;bcache.bucket_lock[hashcode]); release(\u0026amp;bcache.lock); acquiresleep(\u0026amp;b-\u0026gt;lock); return b; } } if(hashcode2 != hashcode) release(\u0026amp;bcache.bucket_lock[hashcode2]); // 释放其他桶锁 } panic(\u0026#34;bget: no buffers\u0026#34;); } // Return a locked buf with the contents of the indicated block. struct buf* bread(uint dev, uint blockno) { struct buf *b; b = bget(dev, blockno); if(!b-\u0026gt;valid) { virtio_disk_rw(b, 0); b-\u0026gt;valid = 1; } return b; } // Write b\u0026#39;s contents to disk. Must be locked. void bwrite(struct buf *b) { if(!holdingsleep(\u0026amp;b-\u0026gt;lock)) panic(\u0026#34;bwrite\u0026#34;); virtio_disk_rw(b, 1); } // Release a locked buffer. // Move to the head of the most-recently-used list. void brelse(struct buf *b) { if(!holdingsleep(\u0026amp;b-\u0026gt;lock)) panic(\u0026#34;brelse\u0026#34;); releasesleep(\u0026amp;b-\u0026gt;lock); int hashcode = b-\u0026gt;blockno % NBUCKET; // 计算哈希值 acquire(\u0026amp;bcache.bucket_lock[hashcode]); // 只获取对应桶锁 b-\u0026gt;refcnt--; if (b-\u0026gt;refcnt == 0) { // no one is waiting for it. b-\u0026gt;next-\u0026gt;prev = b-\u0026gt;prev; b-\u0026gt;prev-\u0026gt;next = b-\u0026gt;next; b-\u0026gt;next = bcache.bucket[hashcode].next; b-\u0026gt;prev = \u0026amp;bcache.bucket[hashcode]; bcache.bucket[hashcode].next-\u0026gt;prev = b; bcache.bucket[hashcode].next = b; } release(\u0026amp;bcache.bucket_lock[hashcode]); } void bpin(struct buf *b) { acquire(\u0026amp;bcache.bucket_lock[b-\u0026gt;blockno % NBUCKET]); b-\u0026gt;refcnt++; release(\u0026amp;bcache.bucket_lock[b-\u0026gt;blockno % NBUCKET]); } void bunpin(struct buf *b) { acquire(\u0026amp;bcache.bucket_lock[b-\u0026gt;blockno % NBUCKET]); b-\u0026gt;refcnt--; release(\u0026amp;bcache.bucket_lock[b-\u0026gt;blockno % NBUCKET]); } 实验结果 \u0026hellip; \u0026hellip;\n","date":"2025-07-11T20:53:48+08:00","permalink":"https://chenby99.github.io/p/mit6.1810lab7-lock/","title":"[mit6.1810]Lab7: Lock"},{"content":" 【写在前面】\n这是2023-2024春季学期操作系统课程有关xv6 lab部分的实验报告，参考了很多网络资源，解释也不一定正确，仅作为留档，参考需谨慎。\nLab 地址：6.1810 / Fall 2024\n参考：\nMIT 6.S081_Zheyuan Zou的博客-CSDN博客\nyali-hzy/xv6-labs-2024: MIT 6.1810 assignments\n【露说xv6】Lab4-traps_哔哩哔哩_bilibili\nAlarm 实验任务分析 实验要求在xv6中新增一个特性：在进程使用CPU的时间内，xv6定期向进程发出警报。\ntest0: invoke handler 问题：需要添加一个新的系统调用sigalarm(interval, handler)。这个系统调用可以设置一个进程被时钟打断的间隔(Inteval)和响应函数(handler)。例如当调用了sigalarm(n, fn)，这个进程就会以n的时间间隔调用处理函数fn。当fn返回时，应用应当在它离开的地方恢复执行。\n实现思路：\nsigalarm在内核的实现sys_sigalarm需要将用户传进来的参数记录到proc结构体中，此外还添加了一个用于表示当前进程是否处于响应alarm中的标志位\n根据提示“Every tick, the hardware clock forces an interrupt, which is handled in usertrap() in kernel/trap.c. ”需要在usertrap()中找到对应时钟中断的位置进行处理：如果时间达到了我们设定的间隔，则触发alarm响应过程\n1 2 // kernel/trap.c/usertrap() if(which_dev == 2) ... test1/test2()/test3(): resume interrupted code 问题：由于将中断处理函数放入到了进程的proc结构体中，当函数执行完毕后，我们需要对进程的现场进行恢复，所以需要添加另一个新的系统调用sigreturn。\n实现思路：\n在usertrap() 中将trapframe完全保存，设置trapframe中的epc寄存器的值设置为handler的虚拟地址，使其可以经由usertrapret返回到用户态下的handler函数中去\n在sigreturn在内核的实现sys_sigreturn中：将trapframe恢复，并重置标志位\n根据提示“Make sure to restore a0. sigreturn is a system call, and its return value is stored in a0. ”，返回a0\n具体实现代码 准备工作：新增一个系统调用（类似Lab2）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // Makefile UPROGS=\\ $U/_cat\\ ...... $U/_alarmtest\\ // user/user.h int sigalarm(int, void (*handler)()); int sigreturn(void); // user/usys.pl entry(\u0026#34;sigalarm\u0026#34;); entry(\u0026#34;sigreturn\u0026#34;); // kernel/syscall.h #define SYS_sigalarm 22 #define SYS_sigreturn 23 // kernel/syscall.c extern uint64 sys_sigalarm(void); extern uint64 sys_sigreturn(void); [SYS_sigalarm] sys_sigalarm, [SYS_sigreturn] sys_sigreturn, 在proc.h中声明新添加到进程结构体中的变量\n1 2 3 4 5 struct trapframe *pre_trapframe; // 保存处理前的trapframe int alarm_internel; // 触发alarm handler的时间间隔 uint64 handler; // handler在用户态的虚拟地址 int crt_ticks; // 记录从上次触发handler到现在经过的ticks数量 int Handling; // 标志位，表示当前进程是否处于响应alarm中 并在proc.c中初始化\n1 2 3 4 5 6 7 8 9 //static struct proc* allocproc() if((p-\u0026gt;pre_trapframe = (struct trapframe *)kalloc()) == 0){ freeproc(p); release(\u0026amp;p-\u0026gt;lock); return 0; } p-\u0026gt;crt_ticks = 0; p-\u0026gt;handler = -1; p-\u0026gt;alarm_internel = 0; sysproc.c添加两个新系统调用实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 uint64 sys_sigalarm(void) { int ticks; uint64 handler; // 从用户空间获取参数ticks和handler argint(0,\u0026amp;ticks); argaddr(1,\u0026amp;handler); struct proc* p = myproc(); // 获取当前进程 p-\u0026gt;crt_ticks = 0; // 重置计数器 p-\u0026gt;alarm_internel = ticks; // 设施报警间隔 if(ticks ==0 \u0026amp;\u0026amp; handler ==0){ p-\u0026gt;handler = -1; // 如果ticks和handler都为 0，清除报警设置防止程序崩溃 } else{ p-\u0026gt;handler = handler; // 设置handler } return 0; } uint64 sys_sigreturn(void) { struct proc* p = myproc(); // 获取当前进程 memmove(p-\u0026gt;trapframe, p-\u0026gt;pre_trapframe, sizeof(struct trapframe)); // 恢复现场 p-\u0026gt;crt_ticks = 0; // 重置计数器 p-\u0026gt;Handling = 0; // 重置标志位 return p-\u0026gt;trapframe-\u0026gt;a0; } trap.c中修改usertrap()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // give up the CPU if this is a timer interrupt. if(which_dev == 2){ if(!(p-\u0026gt;handler == 0 \u0026amp;\u0026amp; p-\u0026gt;handler == -1)){ // 如果有成功获取参数 p-\u0026gt;crt_ticks++; // 计数器计数 if(p-\u0026gt;crt_ticks == p-\u0026gt;alarm_internel \u0026amp;\u0026amp; p-\u0026gt;alarm_internel \u0026gt; 0){ // 检查是否达到alarm间隔 p-\u0026gt;crt_ticks = 0; // 重置 tick 计数器 if(!p-\u0026gt;Handling){ // 如果没有在处理alarm p-\u0026gt;Handling = 1; // 设置标志位 memmove(p-\u0026gt;pre_trapframe, p-\u0026gt;trapframe, sizeof(struct trapframe)); // 保存现场 p-\u0026gt;trapframe-\u0026gt;epc = p-\u0026gt;handler; // 设置trapframe的epc为handler地址 } } } yield(); } 运行结果 \u0026hellip;\n测试程序结果：\n","date":"2025-07-11T20:44:33+08:00","permalink":"https://chenby99.github.io/p/mit6.1810lab4-traps/","title":"[mit6.1810]Lab4: traps"},{"content":" 【写在前面】\n这是2023-2024春季学期操作系统课程有关xv6 lab部分的实验报告，参考了很多网络资源，解释也不一定正确，仅作为留档，参考需谨慎。\nLab 地址：6.1810 / Fall 2024\n参考：\nMIT 6.S081_Zheyuan Zou的博客-CSDN博客\nyali-hzy/xv6-labs-2024: MIT 6.1810 assignments\n【露说xv6】Lab3-Three Important Parts_哔哩哔哩_bilibili\n【露说xv6】Lab3-Problems_哔哩哔哩_bilibili\nPrint a page table 实验任务分析 实验任务要求将一个进程的页表按照指定格式打印出来。\n实现思路：\n在 kernel/vm.c 中新增函数vmprint实现打印功能，并在 kernel/defs.h 中声明\n根据提示“The function freewalk may be inspirational. ”阅读freewalk源码如下，可以发现他是一个用于递归地释放一个页表及其关联的所有子页表所占用的内存的函数。所以我们的代码也可以使用递归的逻辑。\n为了控制打印的格式，具体实现中额外多定义了一个函数void ptePrint(pagetable_t pagetable, int level, uint64 baseP)，主要用于按照页表的层次打印指定数量的缩进符\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void freewalk(pagetable_t pagetable) { // there are 2^9 = 512 PTEs in a page table. for(int i = 0; i \u0026lt; 512; i++){ pte_t pte = pagetable[i]; if((pte \u0026amp; PTE_V) \u0026amp;\u0026amp; (pte \u0026amp; (PTE_R|PTE_W|PTE_X)) == 0){ // this PTE points to a lower-level page table. uint64 child = PTE2PA(pte); freewalk((pagetable_t)child); pagetable[i] = 0; } else if(pte \u0026amp; PTE_V){ panic(\u0026#34;freewalk: leaf\u0026#34;); } } kfree((void*)pagetable); } 具体代码 在vm.c中新增函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 // 用于按照格式递归地打印页表 void ptePrint(pagetable_t pagetable, int level, uint64 baseP) { if(level \u0026lt; 0) // 遍历完所有页表层级，结束递归调用 return ; // 遍历页表的每一项（每个页表有 512 个项） for(uint64 i = 0; i \u0026lt; 512; i++) { pte_t pte = pagetable[i]; // 获取当前页表项的值 if(pte \u0026amp; PTE_V){ // 判断有效 uint64 next_baseP = baseP + (i \u0026lt;\u0026lt; PXSHIFT(level)); // 计算下一级页表项的虚拟地址偏移 pagetable_t next_pgt = (pagetable_t)PTE2PA(pte); // 提取物理地址 uint64 pnn = (uint64)next_pgt \u0026gt;\u0026gt; 12; // 提取物理页帧号 // 打印缩进，表示当前页表项所在的层级 for(int j = level; j \u0026lt; 3; j++) printf(\u0026#34; ..\u0026#34;); // 打印页表项的详细信息：索引、地址、物理页帧号 printf(\u0026#34;%ld: pte %p (\u0026#34;, i, (uint64*)pte); if (pte \u0026amp; PTE_R) printf(\u0026#34;R\u0026#34;); if (pte \u0026amp; PTE_W) printf(\u0026#34;W\u0026#34;); if (pte \u0026amp; PTE_X) printf(\u0026#34;X\u0026#34;); if (pte \u0026amp; PTE_U) printf(\u0026#34;U\u0026#34;); printf(\u0026#34;) pa %ld(th pages)\\n\u0026#34;,pnn); // 递归调用遍历下一级页表 ptePrint(next_pgt, level - 1, next_baseP); } } } void vmprint(pagetable_t pagetable) { printf(\u0026#34;page table %p\\n\u0026#34;, pagetable); // 打印根页表的基地址 ptePrint(pagetable, 2, 0); // 从根页表开始 递归遍历和打印 } 运行结果 回答问题 示例输出：\n问题1：为什么第一对括号为空？32618在物理内存的什么位置，为什么不从低地址开始？结合源代码内容进行解释。\n第一行的页表为非叶子页表项。在 xv6 的多级页表中，权限标志位（如 PTE_V、PTE_R、PTE_W、PTE_X、PTE_U 等）主要存在于叶子页表项，因为只有叶子页表项直接映射到物理内存页面。\n查看源码，mappages 函数用于将物理内存映射到虚拟地址空间，并设置权限标志位。它调用 walk 函数来找到或创建叶子页表项，并设置权限标志位。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm) { ... a = va; last = va + size - PGSIZE; for (;;){ if ((pte = walk(pagetable, a, 1)) == 0) // 此处返回叶子页表项 return -1; if (*pte \u0026amp; PTE_V) panic(\u0026#34;mappages: remap\u0026#34;); *pte = PA2PTE(pa) | perm | PTE_V; // 设置权限标志位 ... } 32618 是物理页帧号，物理页帧的大小通常为 4KB = 4096bits（即 PGSIZE），所以 32618 号物理页帧在物理内存中的起始地址为 32618 * PGSIZE。\n在 xv6 操作系统中，物理内存被分为多个部分，一般低地址区域被内核代码、数据、设备映射占用，因此页表等动态分配的内存位于高地址。阅读源码kernel/kalloc.c中kinit()函数可知，xv6 使用从内核结尾到 PHYSTOP 之间的物理内存为运行时分配提供内存资源。\n1 2 3 4 5 6 void kinit() { initlock(\u0026amp;kmem.lock, \u0026#34;kmem\u0026#34;); freerange(end, (void*)PHYSTOP); } 问题2：这是什么页？装载的什么内容？结合源代码内容进行解释。\n该页表项具有 R（读）、W（写）、X（执行）以及 U（用户模式可访问）权限标志位。根据其虚拟地址va 0x0000000000000000，并参考xv6地址空间中的用户部分分配可知为用户代码页。\n装载了用户初始代码\n用户初始代码由 uvmfirst() 加载到物理页面，并将其映射到虚拟地址0处，确保第一个用户进程初始化时能正确访问其代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // Load the user initcode into address 0 of pagetable, // for the very first process. // sz must be less than a page. void uvmfirst(pagetable_t pagetable, uchar *src, uint sz) { char *mem; if(sz \u0026gt;= PGSIZE) panic(\u0026#34;uvmfirst: more than a page\u0026#34;); mem = kalloc(); memset(mem, 0, PGSIZE); mappages(pagetable, 0, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_X|PTE_U); memmove(mem, src, sz); } 问题3：这是什么页，有何功能？为什么没有U标志位？\n这是trapframe页\n它的功能是存储系统调用时的寄存器状态，供 trampoline 代码使用\n没有 U 标志位：trapframe 页仅供内核使用，不需要用户模式访问。\n1 2 3 4 5 6 if(mappages(pagetable, TRAPFRAME, PGSIZE, (uint64)(p-\u0026gt;trapframe), PTE_R | PTE_W) \u0026lt; 0){ uvmunmap(pagetable, TRAMPOLINE, 1, 0); uvmfree(pagetable, 0); return 0; } 问题4：这是什么页？装载的什么内容？指出源代码初始化该页的位置。\n该页表项具有 R（读）、W（写）、X（执行）以及 U（用户模式可访问）权限标志位。根据其虚拟地址va 0x0000000000002000，并参考xv6地址空间中的用户部分分配可知为用户数据页。\n装载了用户数据\n源码初始化位置（kernel/proc.c）：用户数据由 uvmalloc() 分配，初始权限为 PTE_R | PTE_W | PTE_U：\n1 2 3 4 uint64 uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz) { // ... mappages(pagetable, a, PGSIZE, (uint64)mem, PTE_R | PTE_W | PTE_U); } 问题5：这是什么页，为何没有X标志位？\n内核数据页（va=0x0000003fffffe000），权限 RW（内核可读/写）。 无 X 标志：数据页无需执行权限，防止代码注入攻击，提高安全性。 问题6：这是什么页，为何没有W标志位？装载的内容是什么？为何这里的物理页号处于低地址区域（第7页）？结合源代码对应的操作进行解释。\nTrampoline 页（跳板页），权限 RX（内核可读/执行），无 W 和 U，因为Trampoline 代码必须是只读的，防止用户或内核修改其内容。\n装载内容了trampoline.S 中的汇编代码（用户/内核切换逻辑）。\nTrampoline 页在内核启动时（main() 前）静态分配，占用固定低物理地址（物理页7）。源码中由 kvminit() 直接映射到高虚拟地址，但物理页在低地址保留：\n1 2 // kernel/vm.c: kvmmake() kvmmap(kernel_pagetable, TRAMPOLINE, (uint64)trampoline, PGSIZE, PTE_R | PTE_X); trampoline 符号链接到低地址（kernel/kernel.ld ）：\n1 2 3 . = 0x80000000; // 内核虚拟地址起始 .text : { *(.text .text.*) } .trampoline : { *(.trampoline) } // 位于0x7000（低物理地址） Use superpages 实验任务分析 实验要求实现对超级页的支持，当用户程序通过 sbrk() 系统调用请求 2MB 或更大的内存时，内核应使用超级页进行内存分配。这需要修改内核的内存管理和页表处理逻辑，使系统能够识别和管理超级页。\n这需要实现超级页物理内存的分配与释放，以及超级页虚拟内存的管理。\n实现思路：\n物理内存的分配/释放\n在kmem中添加一个run结构体变量用于指向一个空闲超级页（2MB）的链表 在freerange 函数中添加用于释放超级页的物理内存区域的代码 仿照kfree和kalloc函数，添加superfree 函数用于释放一个超级页，并添加superalloc 函数用于分配一个超级页 虚拟内存的管理\n根据提示“A good place to start is sys_sbrk in kernel/sysproc.c, which is invoked by the sbrk system call. Follow the code path to the function that allocates memory for sbrk.”\n1 2 3 4 5 6 7 8 9 10 11 12 uint64 sys_sbrk(void) { uint64 addr; int n; argint(0, \u0026amp;n); addr = myproc()-\u0026gt;sz; if(growproc(n) \u0026lt; 0) return -1; return addr; } 可以观察到sys_sbrk调用了growproc函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int growproc(int n) { uint64 sz; struct proc *p = myproc(); sz = p-\u0026gt;sz; if(n \u0026gt; 0){ if((sz = uvmalloc(p-\u0026gt;pagetable, sz, sz + n, PTE_W)) == 0) { return -1; } } else if(n \u0026lt; 0){ sz = uvmdealloc(p-\u0026gt;pagetable, sz, sz + n); } p-\u0026gt;sz = sz; return 0; } 观察到函数growproc通过参数n来调整进程的内存大小，并且调用了uvmalloc 函数来为用户进程分配虚拟内存。由此可以找到有关管理虚拟内存的代码均在vm.c中。\n新增spuerwalk函数，仿照walk逻辑编写，使其支持在超级页表中查找虚拟地址 va 对应的 PTE。相比walk添加了一个参数l，返回时可以用于标识是超级页(l=1)还是普通页(l=0)\n修改mappages函数，使其支持超级页虚拟内存映射\n修改uvmunmap函数，使其支持解除超级页虚拟内存页面映射，使用 superwalk 函数代替 walk 函数来处理超级页\n修改uvmalloc函数，使其支持超级页虚拟内存分配\n修改uvmcopy函数，使其在复制内存时能够根据情况选择使用超级页或传统页面进行内存分配和映射\n具体代码 物理内存的分配/释放 在kalloc.c中仿照xv6的对普通页的链式管理方式，新增对超级页的管理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 struct { struct spinlock lock; struct run *freelist; #ifdef LAB_PGTBL struct run *superfreelist; // 对超级页的空闲链表 #endif } kmem; void freerange(void *pa_start, void *pa_end) { char *p; p = (char*)PGROUNDUP((uint64)pa_start); #ifndef LAB_PGTBL for(; p + PGSIZE \u0026lt;= (char*)pa_end; p += PGSIZE) kfree(p); #else // 如果支持超级页 int superpg_num = 10; // 预留超级页 char *superp = (char*)SUPERPGROUNDUP((uint64)pa_end - superpg_num * SUPERPGSIZE); // 计算超级页的起始地址，从 pa_end 向下对齐到超级页边界 for(; p + PGSIZE \u0026lt;= superp; p += PGSIZE) kfree(p);// 先释放普通页面部分 for(; superp + SUPERPGSIZE \u0026lt;= (char*)pa_end; superp += SUPERPGSIZE) superfree(superp); // 再释放超级页部分 #endif } #ifdef LAB_PGTBL // 超级页释放函数 void superfree(void *pa) { struct run *r; // 用于表示空闲内存块 if(((uint64)pa % SUPERPGSIZE) != 0 || (char*)pa \u0026lt; end || (uint64)pa \u0026gt;= PHYSTOP) panic(\u0026#34;superfree\u0026#34;); // 参数验证：确保 pa 对齐到超级页大小且在合法内存范围内 // Fill with junk to catch dangling refs. memset(pa, 1, SUPERPGSIZE); r = (struct run*)pa; // 将 pa 转换为 struct run 类型 acquire(\u0026amp;kmem.lock); // 获取自旋锁 r-\u0026gt;next = kmem.superfreelist; kmem.superfreelist = r; // 将超级页插入空闲链表头部 release(\u0026amp;kmem.lock); // 释放锁 } // 超级页分配函数 void * superalloc(void) { struct run *r; acquire(\u0026amp;kmem.lock); // 从空闲链表中取出一个超级页 r = kmem.superfreelist; if(r) kmem.superfreelist = r-\u0026gt;next; release(\u0026amp;kmem.lock); if(r) memset((char*)r, 5, SUPERPGSIZE); // fill with junk return (void*)r; // 返回分配的超级页地址 } #endif 虚拟内存的管理 在riscv.h中对照PGROUNDDOWN和PGROUNDUP添加SUPERPGROUNDDOWN，用于找到当前a所在物理页帧号，返回所在物理页的开始地址\n1 2 #define SUPERPGROUNDUP(sz) (((sz)+SUPERPGSIZE-1) \u0026amp; ~(SUPERPGSIZE-1)) #define SUPERPGROUNDDOWN(a) (((a)) \u0026amp; ~(SUPERPGSIZE-1)) // 新增 在defs.h中声明新增的函数\n1 2 3 void * superalloc(void); void superfree(void *pa); pte_t * superwalk(pagetable_t, uint64, int, int *); 在kernel/vm.c中修改：\nspuerwalk函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #ifdef LAB_PGTBL // 类似walk()逻辑编写 // 函数用于在超级页表中查找虚拟地址 va 对应的 PTE。 // 参数l用于指定页表的起始级别，在遍历过程中更新为实际访问的页表级别后返回 pte_t * superwalk(pagetable_t pagetable, uint64 va, int alloc, int *l) { if(va \u0026gt;= MAXVA) panic(\u0026#34;superwalk\u0026#34;); for(int level = 2; level \u0026gt; *l; level--) { pte_t *pte = \u0026amp;pagetable[PX(level, va)]; // 获取当前层的页表项地址 if(*pte \u0026amp; PTE_V) { // 如果页表项有效 pagetable = (pagetable_t)PTE2PA(*pte); // 转换为物理地址并更新页表指针 if(PTE_LEAF(*pte)) { // 如果是叶节点 *l = level; // 更新实际访问的页表级别 return pte; // 返回页表项地址 } } else { if(!alloc || (pagetable = (pde_t*)kalloc()) == 0) // 如果不需要分配或分配失败 return 0; memset(pagetable, 0, PGSIZE); // 初始化新分配的页表 *pte = PA2PTE(pagetable) | PTE_V; // 更新页表项为有效 } } return \u0026amp;pagetable[PX(*l, va)]; // 返回目标页表项地址 } #endif mappages函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm) { uint64 a, last; pte_t *pte; if((va % PGSIZE) != 0) panic(\u0026#34;mappages: va not aligned\u0026#34;); if((size % PGSIZE) != 0) panic(\u0026#34;mappages: size not aligned\u0026#34;); if(size == 0) panic(\u0026#34;mappages: size\u0026#34;); a = va; last = va + size - PGSIZE; for (;;) { #ifdef LAB_PGTBL //int sz = PGSIZE; int use_superpage = 0; // 用于标识是否使用超级页面映射 // 判断是否可以使用超级页面映射 if ((a % SUPERPGSIZE) == 0 \u0026amp;\u0026amp; (a + SUPERPGSIZE \u0026lt;= last + PGSIZE) \u0026amp;\u0026amp; (perm \u0026amp; PTE_U)) { use_superpage = 1; // 更改标识 //sz = SUPERPGSIZE; } if (use_superpage) { int l = 1; if ((pte = superwalk(pagetable, a, 1, \u0026amp;l)) == 0) // 查找或创建超级页面对应的PTE return -1; } else { if ((pte = walk(pagetable, a, 1)) == 0) return -1; } #else // 如果不能使用超级页面映射 就用普通页 if ((pte = walk(pagetable, a, 1)) == 0) return -1; #endif // 检查PTE是否已经被标记为有效 if (*pte \u0026amp; PTE_V) panic(\u0026#34;mappages: remap\u0026#34;); *pte = PA2PTE(pa) | perm | PTE_V; // 将物理地址转换为PTE格式 并加上权限位和有效位 #ifdef LAB_PGTBL if (use_superpage) { //如果使用超级页 if (a + SUPERPGSIZE == last + PGSIZE) // 检查是否已经映射到最后一个超级页面 break; // 更新起始地址和物理地址 a += SUPERPGSIZE; pa += SUPERPGSIZE; } else { if (a == last) break; a += PGSIZE; pa += PGSIZE; } #else //不使用超级页 if (a == last) break; a += PGSIZE; pa += PGSIZE; #endif } return 0; } uvmunmap函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 void uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free) { uint64 a; pte_t *pte; int sz; if((va % PGSIZE) != 0) panic(\u0026#34;uvmunmap: not aligned\u0026#34;); for(a = va; a \u0026lt; va + npages*PGSIZE; a += sz){ sz = PGSIZE; #ifdef LAB_PGTBL int l = 0; // 标志变量 用于确定是超级页还是普通页。 int flag = 0; // 标记是否已经处理过超级页 if((pte = superwalk(pagetable, a, 0, \u0026amp;l)) == 0) panic(\u0026#34;uvmunmap: walk\u0026#34;); #else if((pte = walk(pagetable, a, 0)) == 0) panic(\u0026#34;uvmunmap: walk\u0026#34;); #endif if((*pte \u0026amp; PTE_V) == 0) { printf(\u0026#34;va=%ld pte=%ld\\n\u0026#34;, a, *pte); panic(\u0026#34;uvmunmap: not mapped\u0026#34;); } if(PTE_FLAGS(*pte) == PTE_V) panic(\u0026#34;uvmunmap: not a leaf\u0026#34;); if(do_free){ // 解除虚拟内存页面映射具体操作 uint64 pa = PTE2PA(*pte); // 从页表项中提取物理地址 #ifdef LAB_PGTBL if(l == 1) { // 如果是超级页 int perm = *pte \u0026amp; 0xFFF; // 获取权限 *pte = 0; // 清空页表项 flag = 1; // 设置标志 sz = SUPERPGSIZE; // 更新大小为超级页大小 if(a % SUPERPGSIZE != 0){ // 如果虚拟地址未对齐到超级页 // 对齐到超级页边界 for(uint64 i = SUPERPGROUNDDOWN(a); i \u0026lt; va; i += PGSIZE) { char *mem = kalloc(); // 分配新的物理页面 if(mem == 0) panic(\u0026#34;uvmunmap: kalloc\u0026#34;); mappages(pagetable, i, PGSIZE, (uint64)mem, perm); // 将新分配的页面映射到虚拟地址空间 memmove(mem, (char*)pa + i - SUPERPGROUNDDOWN(a), PGSIZE); // 将数据从超级页复制到新分配的页面 } a = SUPERPGROUNDUP(a); // 更新虚拟地址 sz = 0; // 更新大小 } superfree((void*)pa); // 释放超级页 } else #endif // 如果是普通页 kfree((void*)pa); // 释放普通页 } #ifdef LAB_PGTBL if(flag == 0) // 避免使用超级页时候被重复清除 #endif *pte = 0; } } uvmalloc函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 uint64 uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz, int xperm) { char *mem; uint64 a; int sz; if(newsz \u0026lt; oldsz) return oldsz; oldsz = PGROUNDUP(oldsz); for(a = oldsz; a \u0026lt; newsz; a += sz){ sz = PGSIZE; #ifdef LAB_PGTBL // 判断是否可以使用超级页 if (newsz - a \u0026gt;= SUPERPGSIZE \u0026amp;\u0026amp; a % SUPERPGSIZE == 0) { sz = SUPERPGSIZE; // 更新大小为超级页 mem = superalloc(); // 分配超级页大小的物理内存 } else #endif mem = kalloc(); if(mem == 0){ uvmdealloc(pagetable, a, oldsz); return 0; } #ifndef LAB_SYSCALL memset(mem, 0, sz); #endif if(mappages(pagetable, a, sz, (uint64)mem, PTE_R|PTE_U|xperm) != 0){ #ifdef LAB_PGTBL if(sz == SUPERPGSIZE) // 如果分配的是超级页大小内存 superfree(mem); // 释放超级页内存 else #endif kfree(mem); uvmdealloc(pagetable, a, oldsz); return 0; } } return newsz; } uvmcopy函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 int uvmcopy(pagetable_t old, pagetable_t new, uint64 sz) { pte_t *pte; uint64 pa, i; uint flags; char *mem; int szinc; for(i = 0; i \u0026lt; sz; i += szinc){ szinc = PGSIZE; #ifdef LAB_PGTBL int l = 0; // 标志变量 用于确定是普通页还是超级页 if((pte = superwalk(old, i, 0, \u0026amp;l)) == 0) // 如果是超级页l=1,普通页l=0 panic(\u0026#34;uvmcopy: pte should exist\u0026#34;); #else if((pte = walk(old, i, 0)) == 0) panic(\u0026#34;uvmcopy: pte should exist\u0026#34;); #endif if((*pte \u0026amp; PTE_V) == 0) panic(\u0026#34;uvmcopy: page not present\u0026#34;); pa = PTE2PA(*pte); flags = PTE_FLAGS(*pte); #ifdef LAB_PGTBL if(l == 1) { // 如果是超级页 szinc = SUPERPGSIZE; // 将地址增量设置为超级页的大小 if((mem = superalloc()) == 0) // 分配超级页大小的内存 goto err; memmove(mem, (char*)pa, SUPERPGSIZE); // 将超级页大小的物理内存从旧地址复制到新分配的内存地址 if(mappages(new, i, SUPERPGSIZE, (uint64)mem, flags) != 0){ // 将超级页大小的新内存映射到新页表的虚拟地址 superfree(mem); // 释放之前分配的超级页内存 goto err; } } else { // 如果是普通页 #endif if((mem = kalloc()) == 0) goto err; memmove(mem, (char*)pa, PGSIZE); if(mappages(new, i, PGSIZE, (uint64)mem, flags) != 0){ kfree(mem); goto err; } #ifdef LAB_PGTBL } #endif } return 0; err: uvmunmap(new, 0, i / PGSIZE, 1); return -1; } 运行结果 ","date":"2025-07-11T20:23:24+08:00","permalink":"https://chenby99.github.io/p/mit6.1810lab3-page-tables/","title":"[mit6.1810]Lab3: page tables"},{"content":" 【写在前面】\n这是2023-2024春季学期操作系统课程有关xv6 lab部分的实验报告，参考了很多网络资源，解释也不一定正确，仅作为留档，参考需谨慎。\nLab 地址：6.1810 / Fall 2023\n参考：\nMIT 6.S081_Zheyuan Zou的博客-CSDN博客\n【露说xv6】Lab2-Basic and Optional（985男大的初学案例分享）_哔哩哔哩_bilibili\nUsing gdb Q1: Looking at the backtrace output, which function called syscall?\nA1: usertrap()调用了syscall\nQ2: What is the value of p-\u0026gt;trapframe-\u0026gt;a7 and what does that value represent?\nA2: p /x p-\u0026gt;trapframe-\u0026gt;a7 = 0x7 由此可知，在syscall.h中找到#define SYS_exec 7，在 user/initcode.S查看：xv6 启动的第一个用户程序为SYS_exec\nQ3: What was the previous mode that the CPU was in?\nA3: sstatus = 0x200000022，将sstatus转化为二进制表示，其中第八位为0（0表示用户态，1表示核心态），所以CPU处于用户态。\nQ4: Write down the assembly instruction the kernel is panicing at. Which register corresponds to the variable num?\nA4:instruction: lw a3,0(zero)#0\u0026lt;entry-0x80000000\u0026gt;；register: a3\nQ5: Why does the kernel crash? Hint: look at figure 3-3 in the text; is address 0 mapped in the kernel address space? Is that confirmed by the value in scause above?\nA5: 访问0地址时超出列表出错；0地址不会被映射到空间；由输出scause 0x000000000000000d可知，对应RISC-V表中0/13，显示 “Load page fault\u0026quot; 表示加载列表出现错误，相符。\nQ6: What is the name of the binary that was running when the kernel paniced? What is its process id (pid)?\nA6: name of the binary: initcode 000\\000\\000\\000\\000\\000\\000'；pid = 1\nSystem call tracing 添加一个系统调用：\n在user.h中添加：int trace(int);\n在usys.pl中添加：entry(\u0026quot;trace\u0026quot;);\n在syscall.h中添加：#define SYS_trace 23\n在syscall.c中添加函数声明extern uint64 sys_trace(void);和函数列表[SYS_trace] sys_trace,\n加入一个表示用于进程追踪的掩码\n在proc.c中新增变量声明int traceMask;用于接受参数mask。在生成proc时会调用函数allocproc，严谨地在该函数中初始化变量p-\u0026gt;traceMask=0;\n在sysproc.c的文件中真正地实现sys_trace的逻辑\n在sysproc.c中添加函数定义：\n1 2 3 4 5 6 7 8 9 uint64 sys_trace(void) { int flag; argint(0, \u0026amp;flag); // 将trapframe-\u0026gt;a0读入（详细查看argraw()) struct proc* p=myproc(); p-\u0026gt;traceMask=flag; return 0; } 在函数fork()中添加np-\u0026gt;traceMask = p-\u0026gt;traceMask; 将参数复制到子进程中\n在syscall.c中还需要加一个系统调用号到名称的映射表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 static char* SyscallName[] = { [SYS_fork] \u0026#34;fork\u0026#34;, [SYS_exit] \u0026#34;exit\u0026#34;, [SYS_wait] \u0026#34;wait\u0026#34;, [SYS_pipe] \u0026#34;pipe\u0026#34;, [SYS_read] \u0026#34;read\u0026#34;, [SYS_kill] \u0026#34;kill\u0026#34;, [SYS_exec] \u0026#34;exec\u0026#34;, [SYS_fstat] \u0026#34;fstat\u0026#34;, [SYS_chdir] \u0026#34;chdir\u0026#34;, [SYS_dup] \u0026#34;dup\u0026#34;, [SYS_getpid] \u0026#34;getpid\u0026#34;, [SYS_sbrk] \u0026#34;sbrk\u0026#34;, [SYS_sleep] \u0026#34;sleep\u0026#34;, [SYS_uptime] \u0026#34;uptime\u0026#34;, [SYS_open] \u0026#34;open\u0026#34;, [SYS_write] \u0026#34;write\u0026#34;, [SYS_mknod] \u0026#34;mknod\u0026#34;, [SYS_unlink] \u0026#34;unlink\u0026#34;, [SYS_link] \u0026#34;link\u0026#34;, [SYS_mkdir] \u0026#34;mkdir\u0026#34;, [SYS_close] \u0026#34;close\u0026#34;, [SYS_trace] \u0026#34;trace\u0026#34;, }; 测试结果\n\u0026hellip;\n","date":"2025-07-11T20:08:07+08:00","permalink":"https://chenby99.github.io/p/mit6.1810lab2-system-calls/","title":"[mit6.1810]Lab2: system calls"},{"content":" 【写在前面】\n这是2023-2024春季学期操作系统课程有关xv6 lab部分的实验报告，参考了很多网络资源，解释也不一定正确，仅作为留档，参考需谨慎。\nLab 地址：6.1810 / Fall 2023\n参考：MIT 6.S081_Zheyuan Zou的博客-CSDN博客\nsleep 应用层 在 sleep 程序中，用户通过命令行输入一个时间参数，程序调用 sleep 系统调用使当前进程暂停指定的时间。\n1 2 time = atoi(argv[1]); // 将字符串参数转换为整数 sleep(time); // 调用 sleep 系统调用，使进程暂停 系统调用 当 sleep 被调用时，它是一个系统调用，会触发一个上下文切换，从用户空间切换到内核空间。\n上下文切换：保存当前进程的上下文（包括寄存器状态、程序计数器等），并加载内核的上下文。 系统调用处理：内核接收到 sleep 系统调用后，会将当前进程的状态设置为 SLEEPING，并将其加入到等待队列中。 内核内部 在内核中，sleep 系统调用的处理如下：\n设置进程状态：\n1 current-\u0026gt;state = SLEEPING; 将当前进程的状态设置为 SLEEPING，表示该进程正在等待某个事件（在这里是时间到期）。\n加入等待队列：\n1 sleep_on(\u0026amp;ticks); 将当前进程加入到等待队列中。ticks 是一个全局变量，表示系统启动后的时钟滴答数。\n调度器： 内核的调度器会检查等待队列中的进程。如果进程的等待时间已到（ticks \u0026gt;= current-\u0026gt;wakeup），则将其从等待队列中移除，并将其状态设置为 RUNNABLE。\n唤醒进程： 当进程的等待时间到期后，调度器会将其唤醒，重新加入到就绪队列中，等待被调度运行。\n线程切换 在 sleep 的过程中，内核会切换到其他就绪的进程运行。具体步骤如下：\n保存上下文：保存当前进程的上下文。 选择下一个进程：调度器选择一个就绪的进程。 恢复上下文：恢复新进程的上下文。 切换执行：开始执行新进程。 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; int main(int argc,char* argv[]) { int time; if(argc==1){ // 只输入了一个“sleep” printf(\u0026#34;Please enter a parameter!\\n\u0026#34;); exit(1); // 终止当前进程 无返回 } else if(argc\u0026gt;2){ // 参数过多 printf(\u0026#34;Enter too many parameters!\\n\u0026#34;); exit(1); } time = atoi(argv[1]); // atoi()用于将字符串转化为整数,argv[1]为第二个输入 sleep(time); exit(0); } // grade-lab-util 是实验环境提供的工具，用于自动化测试和评分 // 测试一下util实验中sleep函数的正确性,在终端输入： // ./grade-lab-util sleep pingpong 应用层 pingpong 程序通过父子进程之间的管道通信实现简单的消息传递。\n1 2 3 4 5 6 pipe(p); // 创建管道 if (fork() == 0) { // 子进程 // 子进程从管道读取数据，然后写入数据 } else { // 父进程 // 父进程写入数据，然后从管道读取数据 } 系统调用 pipe 系统调用：\n1 pipe(p); 创建一个管道，返回两个文件描述符：p[0] 用于读取，p[1] 用于写入。\nfork 系统调用：\n1 fork(); 创建一个子进程。子进程继承父进程的文件描述符。\nread 和 write 系统调用：\n1 2 read(p[0], \u0026amp;receive, 1); write(p[1], \u0026amp;send, 1); 这些调用在父子进程之间传递数据。\n内核内部 pipe 的实现：内核分配一个管道结构体，包含两个文件描述符。设置文件描述符的读写指针。 fork 的实现：创建一个新进程，复制父进程的内存空间和文件描述符。新进程的初始状态为 RUNNABLE。 read 和 write 的实现： write：将数据写入管道的缓冲区。 read：从管道的缓冲区读取数据。如果没有数据可读，进程会被阻塞，直到有数据可用。 线程切换 在 pingpong 程序中，父子进程之间的通信会触发线程切换：\n父进程写入数据：父进程调用 write，将数据写入管道。如果管道缓冲区已满，父进程会被阻塞。 子进程读取数据：子进程调用 read，从管道读取数据。如果管道缓冲区为空，子进程会被阻塞。 调度器的作用：调度器会根据进程的状态（RUNNABLE 或 SLEEPING）选择合适的进程运行。当一个进程被阻塞时，调度器会切换到另一个就绪的进程。 完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; int main(int argc,char* argv[]) { int p[2]; // 管道的两个文件描述符 pipe(p); // 创建一个管道 if(fork()==0){ // 子进程 char send=\u0026#39;a\u0026#39;; char recevie; read(p[0],\u0026amp;recevie,1); // 在没有接收到数据之前，子进程会被阻塞在此 fprintf(1,\u0026#34;%d: received ping\\n\u0026#34;,getpid()); write(p[1],\u0026amp;send,1); } else{ // 父进程 char send=\u0026#39;b\u0026#39;; char receive; write(p[1],\u0026amp;send,1); wait(0); // 等待子进程结束之后再读出子进程的数据，否则可能自发自收 read(p[0],\u0026amp;receive,1); fprintf(1,\u0026#34;%d: received pong\\n\u0026#34;,getpid()); } close(p[0]); // 关闭文件描述符 close(p[1]); exit(0); } find 应用层 find 程序通过递归搜索目录，查找指定的文件名。\n1 find(argv[1], argv[2]); 系统调用 open 系统调用：\n1 open(path, 0); 打开一个目录或文件，返回一个文件描述符。\nread 系统调用：\n1 read(fd, \u0026amp;de, sizeof(de)); 从目录文件描述符中读取目录项。\nstat 系统调用：\n1 stat(buf, \u0026amp;st); 获取文件或目录的状态信息。\n内核内部 open 的实现：内核查找路径对应的文件或目录。分配一个文件表项，设置文件描述符。 read 的实现：内核从目录文件中读取目录项。如果目录项为空，返回 0。 stat 的实现：内核查找路径对应的文件或目录。返回文件或目录的状态信息，包括类型、大小等。 线程切换 在 find 程序中，主要涉及文件系统操作，线程切换较少。但如果文件系统操作阻塞（如磁盘 I/O），调度器会切换到其他就绪的进程。\n完整代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include \u0026#34;kernel/types.h\u0026#34; #include \u0026#34;kernel/stat.h\u0026#34; #include \u0026#34;user/user.h\u0026#34; #include \u0026#34;kernel/fs.h\u0026#34; #include \u0026#34;kernel/fcntl.h\u0026#34; void find(char* path, char* filename) { char buf[512], *p; int fd; struct dirent de; struct stat st; if((fd = open(path, 0)) \u0026lt; 0){ fprintf(2, \u0026#34;find: cannot open %s\\n\u0026#34;, path); return; } //fstat() 用来将参数filedes 所指向的文件状态复制到参数buf 所指向的结构 if(fstat(fd, \u0026amp;st) \u0026lt; 0)\t{ fprintf(2, \u0026#34;find: cannot stat %s\\n\u0026#34;, path); close(fd); return; } //参数错误 if (st.type != T_DIR) { fprintf(2, \u0026#34;usage: find \u0026lt;DIRECTORY\u0026gt; \u0026lt;filename\u0026gt;\\n\u0026#34;); return; } switch(st.type){ case T_FILE: fprintf(2, \u0026#34;find: you are supposed to search for a file in a directory rather than a file \\n\u0026#34;); break; case T_DIR: if(strlen(path) + 1 + DIRSIZ + 1 \u0026gt; sizeof buf){ printf(\u0026#34;find: path too long\\n\u0026#34;); break; } strcpy(buf, path); p = buf+strlen(buf); *p++ = \u0026#39;/\u0026#39;; while(read(fd,\u0026amp;de,sizeof(de)) == sizeof(de)){ if(de.inum == 0) continue; memmove(p, de.name, DIRSIZ); p[DIRSIZ] = 0; if(stat(buf, \u0026amp;st) \u0026lt; 0) { printf(\u0026#34;find: cannot stat %s\\n\u0026#34;, buf); continue; } //不要在“.”和“..”目录中递归 if (st.type == T_DIR \u0026amp;\u0026amp; strcmp(p, \u0026#34;.\u0026#34;) != 0 \u0026amp;\u0026amp; strcmp(p, \u0026#34;..\u0026#34;) != 0) { find(buf, filename); } else if (strcmp(filename, p) == 0) printf(\u0026#34;%s\\n\u0026#34;, buf); } break; } close(fd); } int main(int argc, char* argv[]) { if (argc != 3) { printf(\u0026#34;Parameter missing\\n\u0026#34;); exit(0); } find(argv[1], argv[2]); return 0; } ","date":"2025-07-11T19:55:22+08:00","permalink":"https://chenby99.github.io/p/mit6.1810lab1-utilities/","title":"[mit6.1810]Lab1: Utilities"},{"content":"【写在最前面】\n仅以2023级智科培养方案和博主个人主观感受以及向周边同学了解的情况撰写，智工院近几年培养方案改动较多，仅供参考。博主不是成绩名列前茅的大佬，对课程的学习理解也不完全透彻，如果有评价建议写得与实际不符也请多多担待！\n如果有补充可以写在chenby99chenby99.github.io的issue中或者通过网页页脚的邮箱联系我，希望大家友好交流~~\n自动控制原理 必修/考试课/3学分/平时40% 期末考试60%\n参考教材 自动控制原理(第七版）/ 胡寿松，科学出版社，2019年2月，ISBN：9787030572912\n授课教师 李雪芳： 按ppt教学，课前会发完整一章的ppt，作业在末尾可以提前完成。 语调平缓，讲课细致，选课时人数最多 有签到点名，会数人头，不可代签 李中华： 按ppt教学，课前会发完整一章的ppt，作业在末尾可以提前完成。 前几章每章结束后课堂上有堂练；课堂上会点同学回答问题或上台写题（答不出可以说不会） 期中作业组队，给分高 有签到点名 关于考核 期中布置大作业，内容是matlab仿真pid控制，完成实验报告 期末考试：5题选择（2分*5），9题计算题（10分*9） 2023级：可以携带计算器；考试时间比较紧张，前几道基础计算题过程繁琐；题型与作业类似 学习建议 比较重要的前置知识：复变函数-拉普拉斯变换（传递函数核心）、电路基础（电路数学模型建立\u0026lt;\u0026ndash;考试需掌握）、复变函数-复数计算（频域分析）。老师上课基本细讲不会计算过程，建议课后时自己推导计算一次例题。\nppt基本依据参考教材，教材会写得更详细。\n作业：书本课后练习题，可在网络找到答案。整个学期有一两道练习需要使用软件辅助计算。建议在作业时熟悉计算器使用。\n网课：自动控制理论作为考研科目，知识体系相对成熟，网络资源也很丰富。\n卢老爷带你学系列 | 深入浅出《自动控制原理》（已完结）- bilibili 智能机器人技术 必修/考试课/2学分/平时40% 期末考试60%\n参考教材 机器人学：基础理论与应用实践 / 徐文福，哈尔滨工业大学出版社，2020年5月，ISBN：9787560387369 李孟棠老师用的参考教材会在群里发英文/中文翻译电子版，仅作为参考教材，上课不使用 授课教师 彭键清（前半学期）： 按照ppt教学，课后发ppt 由于内容多学时少所以讲得很快，基本看不完一页ppt就会过到下一页，建议看书自学（不过也有同学在集市吐槽过书编的也一般） 李孟棠（后半学期）： 按照ppt教学，课前发ppt 比较认真讲课的老师，可以听课，学习内容之间的耦合关系比较强，前期概念搞不清楚后面比较难听懂。 作业与考试 前半学期三次作业：需要软件辅助计算，建议学习使用matlab机器人工具箱。第三次作业难度较大。 后半学期三次作业（9、10、11章）：难度适中，与课堂内容强相关，与期末考试强相关。 期中考试：7题计算题，时间充裕，有3~4题是题型相同的求DH参数表 期末考试：选择10题，计算4题，论述题（概念性）3~4题。期末考试主要考察后半学期内容，彭老师只会出1题论述题。23级计算题题型相较作业稍有灵活改动，除了9-11章的计算以外还考了12章的A*图搜索算法。期末考试比期中考试难度大，建议好好准备，ppt上有的东西全都要掌握。 学习建议 两位老师分前后半学期授课，从两种角度讲解机器人学相关知识。\n上半学期有部分知识较难理解，因为老师上课会快速略过非常复杂的推导内容，但实际考核要求并不高。\n下半学期建议好好听课，需要掌握概念大致推导和应用，不能只会做计算题。只要把ppt上的内容学懂，考试问题不大。\n网课：\n【机械臂运动学教程】机械臂+旋转矩阵+变换矩阵+DH+逆解+轨迹规划+机器人+教程_哔哩哔哩_bilibili：上半学期可以参考学习，与课程教学内容不完全相同\n【中英字幕】现代机器人学 | Modern Robotics_哔哩哔哩_bilibili：下半学期教材对应课程，视频较短，可以辅助理解概念\n计算机网络 选修/考试课/2学分/平时40% 期末考试60%\n参考教材 计算机网络：自顶向下方法(原书第7版) / James，F.Kurose，Keith，W.Ross 著，机械工业出版社，ISBN：9787111599715\n授课教师 古博：\n按照ppt讲解，课后发ppt，讲到哪里发到哪里。 理论课没有考勤，实验课签到 待补充 作业与考试 第一章有唯一一次概念问答题作业，很简单。 两次实验报告，部分需要两台主机建立连接的实验使用实验室电脑完成会比较方便，注意实验课时间安排。 论文导读小组pre：8-10人小组，两节课汇报。一个组只有10分钟，到时间直接叫停，汇报人注意时间把控。 期末考试：选择题20题（3分*20）问答题5题。问答题中规中矩，博主觉得有些选择题老师是梦到哪道出哪道，甚至考场上出现重复选项和重复的题目。 学习建议 整体自顶向下学习框架清晰，第一章内容绪论对整体做大致介绍，后面章节一一展开，知识连贯，但细碎的概念很多。不建议死记硬背，理解了再记忆会容易很多。\n教材文字较多较繁琐。\n网课推荐：中科大郑烇、杨坚全套《计算机网络（自顶向下方法 第7版，James F.Kurose，Keith W.Ross）》课程_哔哩哔哩_bilibili：讲得特别好的老师，刚开始可能有点难听进去，但越到后面就会越通透，只要听懂课 知识就会印在你的脑子里。视频课时较长，老师讲专有名词主要使用英文，有一些章节内容会与本课程有差异，自行取舍。\n图像处理 选修/考试课/2学分/平时40% 期末考试60%\n参考教材 数字图像处理（第四版）/ RafaGonzalez, Richard E. Woods著，阮秋琦等译，电子工业出版社，2020年5月，ISBN：9787121377471\n授课教师 高陈强：\n听劝的老师，23级取消了大作业 按照ppt讲课，课前发ppt 平时上课会说“这里考了你们要懂”，期末不划重点 考勤会事先通知，课间扫码签到 作业与考试 部分章节有课后作业，来自书本课后题和老师自己出的题。建议认真对待平时作业，正确率与平时成绩强关联。 期末考试：选择*10（20分），简答*5（40分），计算*3（30分），综合*1（10分）。需要计算器。考试难度适中，比较复杂的公式没有考察，简答题考察概念，计算题与作业计算题型相同，综合题为场景应用，作业也有类似题。 学习建议 内容多，细碎概念多，部分章节无连贯性。建议听课加自己看书理解，避免期末临时死记硬背。教材写的不错，比较容易读懂，但文字量大，ppt基本都是教材内容摘出。\n网课：jiaoyiping的个人空间-jiaoyiping个人主页-哔哩哔哩视频：视频较短，讲解清晰，可以作为预习对知识有大致了解。但不够深入，内容不全。\n数字逻辑设计 选修/考试课/2学分/平时40% 期末考试60%\n参考教材 数字电子技术基础（第六版） / 阎石，高等教育出版社，2016年4月，ISBN：978-7-04-044493-3\n授课教师 杨芳芳 课后讲完一整章才发ppt，作业在ppt末尾 讲课容易卡壳，讲题不算清晰，有时候会讲错 课前签到 魏亮亮 课前发ppt，作业在ppt末尾 讲课细致认真 会随机点名签到 作业与考试 每章布置作业来自书本课后题，难度适中。 期中实验报告：内容是数码管和点阵的（Proteus）仿真显示学号和学校名称实验，提交实验报告和工程文件。杨老师要求显示“中山大学”，魏老师只要求显示“中大“。 期末考试：7道计算题，每章考察1题，题型与作业题相同。时间较紧张。 学习建议 数电理解的难点主要在于元器件的内部实验和静/动态特性，但是实际上考试基本不会考察这一块（因为题型只有计算题且和作业类似）。但如果想更好的理解并且真正掌握数电，还是建议认真学习这部分知识。因为没有模电基础，在门电路章节可能一开始会有些难以理解，可以找一些视频讲解辅助理解。\n教材写的不错，但老师ppt上有部分例题教材没有。\n网课：\n数字电子技术基础 1.1 常用数制及数制的转换_哔哩哔哩_bilibili：讲得很好的老师 《数字电子技术/数字逻辑电路》上集\u0026ndash; 零基础、保姆级_哔哩哔哩_bilibili 数字逻辑设计实验 选修/考查课/2学分\n参考教材 数字电路与逻辑设计实验，中山大学公共实验教学中心，2020年10月，自编教材\n授课教师 魏亮亮：\n课前签到 作业与考试 每节课提交一次实验报告，类似电路基础实验 最后一节课为考核，手写实验报告，不要求仿真，完成后给老师检查实验箱接线和示波器结果。内容为做过的实验稍有改动，难度简单。 学习建议 每次实验分为Proteus仿真和实验箱两个部分，分别完成基本相同的实验内容。\n一开始几节课会给出仿真接线图，后来就不给了。对于理论课有好好学的同学来说，实验内容都不难，而且可以帮助巩固理论知识。\n认知科学基础 选修/考查课/2学分\n参考教材 认知科学导论 / 蔡署山，人民出版社，2021年11月，ISBN：9787010236308\n（教材没有使用过）\n授课教师 王涛\n人很好，讲课认真生动，不过没什么人听课。 有时会点名回答问题，作为签到。 允许学生做自己的事情不听课，但是希望大家准时到课，不要迟到。 作业考核 部分章节ppt后会有问答形式的课后题，在ppt中可以找到答案。 期末大作业开学时布置，题目二选一：1.设计思考类论文，2.鼓励动手实践完成一些仿真实验。要求比较宽泛，有问题可以找老师沟通。课后题和期末报告ddl都是期末考试后，但希望能通过作业有所收获的同学，建议尽早开始做。 操作系统 选修/考查课/2学分\n参考教材 操作系统概念（第10版） / [美] 亚伯拉罕·西尔伯沙茨，机械工业出版社，2023年9月，ISBN：9787111732853\n授课教师 谭光：\n全英课件，中文教学，课前发ppt。有结合代码讲解和xv6实验指导书讲解。 教学平台课间扫码签到 讲课水平待补充 作业考核 三次大作业，包含老师自己出的题目和xv6 lab，提交实验报告。 部分xv6 lab难度大，第三次作业包含optional challenges。 老师明确：“已发现AI生成的报告，一经发现，该次作业打0分；如果期末大作业继续用AI生成，0分处理之外，当做舞弊上报学院。”并且明确严禁抄袭网络资源，会查重。 学习建议 灵活运用ai和网络资源，自行斟酌选课。\n网课：\n绿导师原谅你了的个人空间-绿导师原谅你了个人主页-哔哩哔哩视频：大名鼎鼎jyy。但以我们专业的前置课程想要听懂十分困难，只是给想要深入学习OS的同学一个推荐。 从0开始数的个人空间-从0开始数个人主页-哔哩哔哩视频：有一个操作系统原理合集。很短的5个视频，可以作为概念导入了解。 【操作系统工程】精译【MIT 公开课 MIT6.S081】_哔哩哔哩_bilibili 有关xv6 lab：\nMIT 6.S081_Zheyuan Zou的博客-CSDN博客 yali-hzy/xv6-labs-2024: MIT 6.1810 assignments MIT6.S081 | Miigon\u0026rsquo;s blog Pyroath_Lucia的个人空间-Pyroath_Lucia个人主页-哔哩哔哩视频：有做部分lab的演示视频 传感器原理与应用 选修/考查课/2学分\n文 / Veyme,2025.7\n参考教材 传感器原理及应用 / 吴建平，机械工业出版社，2021年7月，ISBN：978-7-111-68551-7\n（上课不使用教材）\n授课教师 王本斐：\n前半学期讲理论，老师比较专业认真，但是不听也没关系，不考察 会扫码签到 作业考核 五次实验报告，期末考核大作业是自己设计集成各种传感器的电路 下半学期开始做传感器的实验，用的Arduino，代码接线都能参考Arduino配套书籍，不需要前置理论知识，都很简单 期末大作业格式要求会高一点，以论文的形式提交，设计可参考网络资料 学习建议 课程学习比较轻松，可以对各个传感器的原理有一个比较基础的了解，建议选来玩玩。\n","date":"2025-07-11T17:31:15+08:00","permalink":"https://chenby99.github.io/p/%E5%A4%A7%E4%BA%8C%E6%98%A5%E5%AD%A3%E8%AF%BE%E7%A8%8Btips/","title":"大二春季课程tips"}]